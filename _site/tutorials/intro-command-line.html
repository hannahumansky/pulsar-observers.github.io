<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/img/logo.png" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://localhost:4000/tutorials/intro-command-line">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="UVa Pulsar Observers" href="http://localhost:4000///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<meta name="generator" content="Jekyll v3.7.0" />
<meta property="og:title" content="Computing Guide" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Accompanying lecture: Introduction to the Command Line Software to Install Make sure that you have each of the following software packages sucessfully installed before continuing. Mac (OS X) XQuartz Windows 10 The Windows 10 Linux Subsystem Xming WinSCP Windows (Not 10) PuTTY Xming WinSCP Bash and the Command Line You may have heard about using the command line before to interact with a computer. Most scientists are required to interact with computers without a Graphical User Interface (GUI) i.e. without a mouse or a screen. They need to run programs, create programs on remote computers, and move files around all without a mouse and a screen. The way they do this is by interacting with the computer via the command line, basically telling the computer through text what to do instead of through pointing and clicking, as most of us are used to. What is usually meant when people say “I use the command line” or “I use the terminal” is “I use Bash to work on my Unix machine”. Bash is what is known as a shell, which acts as a command interface between you and a computer which is running a Unix based operating system. It basically wraps the operating system with a human interface (hence the name shell). Unix is just a type of operating system, which many other operating systems are based on. Mac operating system OS X is actually based on Unix and there are also many flavors of Linux based on Unix as well (Red Hat, Ubuntu, CentOS, etc.). Windows is completely different, and a lot of the time that makes it unfit for scientific work if you need to use the command line a lot. Getting Set Up Mac (OS X) You already have a Bash command line on your computer! Simply open the application Terminal and you’re ready to go. This will open a Bash shell that lets you interact with your computer textually instead of visually. Windows Unfortunately, Windows is not based on the Unix operating system and thus it does not have a Bash shell. Instead it uses a different shell, which you can access all the same. Simply open the application Command Prompt. To find it, hit the Windows Key. If you are on Windows 10, just start typing “cmd” and it should pop up. On Windows 7, there should be a search function with the same capability, just type “cmd” into there to find the program. Since the shell provided by Windows is not Bash, it is largely irrelevant. If you don’t have Windows 10, this is the end of the road for you, and you’ll have to use PuTTY in order to access another machine which has a bash shell you can use, which we’ll talk about later. If you do have Windows 10, read on. Ubuntu on Windows If you use Windows 10, then you actually already have an Ubuntu installation on your computer. Follow this guide in order to get it set up on your computer. Once you have the Ubuntu subsystem set up, you can access a bash shell by opening the Command Prompt, as before, and simply typing bash to open the bash shell. Now, you’re set up and ready to do some scientific computing! Accesing Far Away Places via SSH Most of the time, scientists don’t run programs and store data on their own computers. Our personal computers simply are not powerful enough, do not have enough disk space, and do not have fast enough internet connections to act as a reasonable computing resource for us. Usually, we use our own command line and the command SSH to access the command line of a different computer.. In Bash Open your Bash shell using one of the methods described above. The syntax to use SSH is pretty simple: ssh &lt;your_user_name&gt;@&lt;domain_name&gt; To log into our computing resources, we will be using the following command: ssh -Y uvastudent@lwalab.phys.unm.edu This command says “Log me into the user uvastudent on the computer accessed by lwalab.phys.unm.edu (a computer at the University of New Mexico).” The -Y means “please forward me the graphics from that computer to mine”. If you have XQuartz (OSX) or XMing (Windows) open on your computer, then when you open a program with a graphical interface on the remote machine, the graphical interface will instead appear on your computer. When accessing the remote computer lwalab.phys.unm.edu for the first time, you will be prompted with a message something like The authenticity of host ... can&#39;t be established. Just type yes when you receive this message. You will also be asked for the password to the uvastudent account. Enter it when prompted. Don’t be worred when no text appears on the screen: it’s there, it’s just invisible. In PuTTY Open PuTTY, then type into the ‘Host Name (or IP address field)’, uvastudent@lwalab.phys.unm.edu. Then click the + next to SSH on the left menu. Then click X11 in the SSH submenu. Click the checkbox next to ‘Enable X11 fowarding’ and in the field ‘X display location’ type 0.0.0.0. This is equivalent to the -Y flag we passed to ssh before. Now click ‘Open’ at the bottom of the screen. Enter the password for our computing account and follow the instructions below. # Once logged into the lwalab.phy.unm.edu computer, run the following command: ssh -Y lwaucf1 You will have to enter the same password again. lwaucf1 can be replaced with lwaucf# (any number 1, 2, 3, 4, 5, or 6) to access any of the 6 LWA UCF computing nodes. Now we are saying, “Using my username (now uvastudent), log into the computer lwaucf#”. Now we are logged into the LWA computing cluster. This is where all of our data will be stored and we will run all of our commands to process the data. Using the Command Line Navigation Once logged in, you will be presented to a shell, similar to your own. We’re going to explore what’s on this computer by using textual commands. To execute a command, you type its name followed by the ‘Enter’ key to execute it. Type ls to list what is in the current directory. You should see two items: examples.desktop and uva_students. Type ls uva_students to list the contents of the uva_students folder. Type cd to change directory into uva_students, which moves you into the folder. Type ls again to list what’s in this directory. You should see another folder called sgs7cr. This is a folder I made for myself. Make a directory by typing mkdir &lt;your_id&gt;, where is replaced with your id. Type `ls` again to confirm your new folder was made. **Change directory** into the folder you just made by typing `cd `. Type `pwd` to **print** the **working directory**. It should output `/home/uvastudent/uva_students/sgs7cr`. Type `cd ~` to return to the home directory, which is where you started from. Type `pwd` again and notice that you are in the `/home/uvastudent` folder. The `~` is just a placeholder for the folder `/home/uvastudent`. These are the basic commands to move around and inspect the your computer’s files and folders: ls, cd. Copying Files The second important thing we do with our computers is move files around, delete them, and rename them. So how do we do that? We’re going to copy a file from my student directory to yours. Make sure you’re in the home directory (cd ~). Then use the command cp uva_students/sgs7cr/steven.txt uva_students/&lt;your_id&gt;/ to copy the file steven.txt to the directory called &lt;your_id&gt;. Notice that we can execute commands at any level of the file system. We can either cd to the folder sgs7cr then execute our cp command, or we can use cp from the home directory and simply specify the full path to the file we want to copy. All cp commands will come in the form cp &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt; Check out the other files that are in my directory using ls uva_students/sgs7cr/. How can we copy all of those files at once? You can do this by using the wildcard character *. * in bash stands for ‘anything’. For example, A* means ‘get me everything that starts with A’. *z means ‘get me everything that ends in z’. A*z means ‘get me everything that starts with A and ends with z’. Let’s copy everything from my directory to yours using the command cp uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ You should get a message cp: omitting directory ‘uva_students/sgs7cr/data’ cp: omitting directory ‘uva_students/sgs7cr/junk_folder’ cp: overwrite ‘uva_students/&lt;your_id&gt;/steven.txt’? . The first two messages mean that cp won’t work with directories. The third message means that the file steven.txt already exists in your directory and thus cp needs to confirm whether you want to keep or overwrite the old file. Simply type y or yes to confirm the request or n or no to deny it. Now, how do we resolve the fact that we can’t copy directories? All you need to do is use the command cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ The -r here simply means recursive and it just tells cp to copy everything from my folder, including all directories and everything inside those directories into the new folder. Before, cp didn’t know what to do when it reached a directory that isn’t empty. Type ls uva_students/&lt;your_id&gt;/ to confirm the contents of your directory. Finally, try running cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ again. You’ll notice that now you get a bunch of messages asking whether cp can overwrite your files. You could just hit y or n for every file that you’re copying. An alternative if you want to overwrite every file automatically is to use the command yes | cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ This command pipes the outpt of the command yes to the cp command. Try typing yes just for fun to see what it does. Type Ctrl+C to stop the infinite output of y. Moving and Renaming Files Similarly to cp, you can move files using the syntax mv &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt; To see this in action, let’s move steven.txt to a different location. Let’s go to your directory using cd uva_students/&lt;your_id&gt; and move the file steven.txt to &lt;your_name&gt;.txt using the command mv steven.txt &lt;your_name&gt;.txt Type ls to list what is in your directory now. Notice that steven.txt is gone and &lt;your_name&gt;.txt took it’s place. We can also use mv to rename files! Removing Files Now how do we delete files? Let’s go into the junk folder in your current directory: cd junk_folder. Type ls to check out what’s in your directory. Now let’s remove a file using rm junk_1.txt Check your directory again to make sure it’s gone. Notice that we also got a confirmation message here. If we don’t want to receive a confirmation message for rm, we can pass it the -f flag to force deletion. Try it: rm -f junk_2.txt Type ls to make sure it’s gone. Now what if we want to get rid of all of the files in this folder? If we remember our handy wildcard symbol * from before, then we could just use the command rm -f * to delete all of the files in the current directory. However, we’re just going to remove the entire junk_folder. Move up one directory using cd ... And now let’s try to remove the folder using rm junk_folder It should say rm: cannot remove ‘junk_folder/’: Is a directory. So how do we remove a directory if we can’t use rm? To make a directory, we used mkdir, so to remove a directory we would think to use rmdir. Try running it: rmdir junk_folder But this still will give an error: rmdir: failed to remove ‘junk_folder/’: Directory not empty. The best way to remove a directory is instead to use rm -r junk_folder Here, the -r means ‘recursive’, which just means when rm tries to remove junk_folder and junk_folder isn’t empty, it will first try to delete everything inside junk_folder by calling rm -r &lt;file&gt; on every file inside junk_folder. You will get a bunch of confirmation messages though asking if you want to enter into the directory and remove files. If we need to delete a lot of files, then this becomes a hassle. Instead, we can use rm -rf junk_folder and if we wanted to remove all files and folders in your current directory we would use rm -rf * !!!WARNING!!! I may have just taught you the most dangerous command you can run. rm -rf * will delete everything in the current directory without prompting you and with no way to recover any of it. Always be careful when removing files and folders using the command line. If you go to the home directory and call rm -rf * on then everyone’s files will be deleted with no way to recover them. Please heed these words of advice: Always be cautious with the commands you are running. It’s VERY likely that you will accidentally delete your own data, or the work of others. This has actually happened before! I’ve heard stories about students who have accidentally deleted the entirety of their research projects, or the entirety of the data they are basing their research on. Okay, now we know how to move about and explore the file system as well as move, copy, and delete files. The last few commands I will show you allow you to check up on the hardware of the computer you are working on. Type into the command line top Top is a simple command that lets you see a summary of the top processes (the ones using the most CPU resources) running on the computer right now. top gives you a lot of information to work with, but the most important things to look at are the columns labeled ‘PID’, ‘USER’, ‘%CPU’, and ‘COMMAND’. ‘COMMAND’ gives you the name of the proccess. For example, if you were running the web browser Firefox, then there would be a process called ‘firefox’ in the ‘COMMAND’ column. Next to ‘firefox’ in the ‘%CPU’ column you can see what percentage of the Central Processing Unit (CPU) Firefox is using. Under USER you can see who is running Firefox. Finally under PID you can see Firefox’s processor ID, which is just a unique numerical label assigned to Firefox. When you want to kill a process, you just type k while in top, then type in the PID of the process. Alternatively, if you know the PID after leaving top, you can return to the command line and type kill &lt;PID&gt; to kill the process. Next, we’ll look at the commands du and df. Go back to your own directory: cd ~/uva_students/&lt;your_id&gt;. Now type du -h du gives you the disk space usage of the current directory you are in. It spits back to you the sizes of all of the files and folders in your current directory. -h here means human readable, meaning it will give you sizes in terms of K, M, G, or T, which stand for kilobyte, megabyte, gigabyte, or terabyte respectively. We can also use the command df -h to show us the disk file system space usage. This means that it will show us how full all of the hard drives that are connected to our computing system are. Notice that a lot of the hard drives are pretty full! This means that we should be respectful of the other users on the system and quickly process, reduce, and delete the raw observational data that we obtain so that the file system doesn’t fill up. Vim - Making and Editting Files Previously, we’ve only moved around and deleted files that others have created? How do we make our own? When working over SSH, the most efficient way to create and edit files it use a slimmed down and efficient text editor, which you probably aren’t used to using. I’m going to be introducing you to one text editor called Vim. Vim Vim is a barebones, command line text editor which is popular among many scientists who have to use the command line a lot. Go to your directory cd ~/uva_students/&lt;your_id&gt;. Now type vim &lt;your_name&gt;.txt to open the text file &lt;your_name&gt;.txt. What you should see is a few lines of text followed by a bunch of tildes on the side and numbers and words on the bottom. Completely foreign and weird I know. Hit i on your keyboard to enter into Insert mode. You’ll notice at the bottom of the screen the words --INSERT--. This means that you can start adding and editing text to the file. Try it out. Use the arrow keys to move around (no way to click around in the command line). Hit Esc on your keyboard to escape to command mode. Now, if you start typing, you’ll notice that text doesn’t get added to the file, and some other weird stuff might happen. Don’t worry though. You only need to hit i to enter Insert mode to type stuff, or Esc to escape from Insert mode. Make sure you’re in the command mode. Now type :w. Notice that now the text shows up at the bottom. That’s because you’re entering a command. Hit Enter on your keyboard to execute :w which tells Vim to write the file. Now type :q to quit Vim. Now open up the text file again in Vim, as before. Enter into Insert mode using i and change the line my name is steven to my name is &lt;your_name&gt;. You can also write and quit at the same time using the command :wq. The way to search files in Vim is by using the command / while in command mode. Type /&lt;your_name&gt; to find your name in the text file. Type /i to find each occurance of the letter ‘i’ in the text file. Hit n on your keyboard to move forward to the next occurance of ‘i’ and type Shift+n to move to the previous occurance of ‘i’. Vim might seem a bit confusing and strange at first, but I promise you it is one of the fastest, most efficient, and most convienient ways to edit text files within the command line, so try to use it! If you hate Vim, there are other alternatives like Emacs and nano, which can be used the same way as Vim from the command line: emacs &lt;your_name&gt;.txt and nano &lt;your_name&gt;.txt But in my opinion, they are way harder to use without much benefit over good old Vim. Slightly More Advanced Stuff screen There’s a neat command called screen which lets you run multiple terminal “screens”. Try it out: screen This should open a new, fresh command line for you to use. Now type Ctrl+A then D to get out of the screen. Notice you get a message saying detached from .... That other bash session we opened is still alive! Type screen -ls To see a list of all of the current screens that are running. You may notice that the names of the screens are just numbers followed by characters. Those characters after the number are the session name, which we can and should specify. For our purposes, you should start new screens using the command screen -S &lt;your_id&gt; Let’s get back to the one you just created though. Type screen -ls to list the current screen and find the one you just opened. You can return to that screen using screen -x &lt;session_id&gt; You don’t have to type the entirety of the session ID, you just need to provide enough characters to differentiate it from all of the others. Since we will be using our user IDs to start new screens, use instead screen -x &lt;your_id&gt; PATH and Environment Variables You may have wondered what these strange commands we are running are. Well, they’re not actually inherent to Bash itself, they’re just programs that Bash knows how to execute. So where are these programs located and how does Bash know where to find them? The answer is the PATH. Type echo $PATH You should get as output /usr/local/sbin:/usr/local/bin:/usr/sbin:..., which is the names of a bunch of directires separated by colons. Each of these is the name is a folder that contains programs that you want Bash to be able to find. Notice that most of the folders have ‘bin’ in their name. This is a convention: On Linux systems, executable programs are usually installed to a folder called ‘bin’. Let’s try confusing Bash. Type export PATH=&quot;&quot; Now try using our old friend ls. It doesn’t work! You should get an error: -bash: ls: No such file or directory. Now type echo $PATH again. Nothing get’s printed out! That’s because in the previous export command we told Bash that the PATH is nothing (&quot;&quot;), therefore Bash has no idea where to look to find any of our programs (including ls). Let’s get things back to normal by typing export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/cuda/bin:/usr/local/tempo2/bin:/usr/local/presto/bin:/usr/local/casapy PATH is what is known in Bash as an ‘environment variable’. An environment variable is just a placeholder for a location (in the case of PATH) or some information that another program or Bash might use. You can set your own environment variables by using the command export &lt;var_name&gt;=&lt;var_defintion&gt; For example, let’s try export &lt;your_id&gt;=/home/uvastudent/uva_students/&lt;your_id&gt;/ Now try cd $&lt;your_id&gt; The $, which we saw before with echo just means replace the environment variable with what it contains. You should find that the previous command took you to your own folder, since $&lt;your_id&gt; was replaced with the path you specified before." />
<meta property="og:description" content="Accompanying lecture: Introduction to the Command Line Software to Install Make sure that you have each of the following software packages sucessfully installed before continuing. Mac (OS X) XQuartz Windows 10 The Windows 10 Linux Subsystem Xming WinSCP Windows (Not 10) PuTTY Xming WinSCP Bash and the Command Line You may have heard about using the command line before to interact with a computer. Most scientists are required to interact with computers without a Graphical User Interface (GUI) i.e. without a mouse or a screen. They need to run programs, create programs on remote computers, and move files around all without a mouse and a screen. The way they do this is by interacting with the computer via the command line, basically telling the computer through text what to do instead of through pointing and clicking, as most of us are used to. What is usually meant when people say “I use the command line” or “I use the terminal” is “I use Bash to work on my Unix machine”. Bash is what is known as a shell, which acts as a command interface between you and a computer which is running a Unix based operating system. It basically wraps the operating system with a human interface (hence the name shell). Unix is just a type of operating system, which many other operating systems are based on. Mac operating system OS X is actually based on Unix and there are also many flavors of Linux based on Unix as well (Red Hat, Ubuntu, CentOS, etc.). Windows is completely different, and a lot of the time that makes it unfit for scientific work if you need to use the command line a lot. Getting Set Up Mac (OS X) You already have a Bash command line on your computer! Simply open the application Terminal and you’re ready to go. This will open a Bash shell that lets you interact with your computer textually instead of visually. Windows Unfortunately, Windows is not based on the Unix operating system and thus it does not have a Bash shell. Instead it uses a different shell, which you can access all the same. Simply open the application Command Prompt. To find it, hit the Windows Key. If you are on Windows 10, just start typing “cmd” and it should pop up. On Windows 7, there should be a search function with the same capability, just type “cmd” into there to find the program. Since the shell provided by Windows is not Bash, it is largely irrelevant. If you don’t have Windows 10, this is the end of the road for you, and you’ll have to use PuTTY in order to access another machine which has a bash shell you can use, which we’ll talk about later. If you do have Windows 10, read on. Ubuntu on Windows If you use Windows 10, then you actually already have an Ubuntu installation on your computer. Follow this guide in order to get it set up on your computer. Once you have the Ubuntu subsystem set up, you can access a bash shell by opening the Command Prompt, as before, and simply typing bash to open the bash shell. Now, you’re set up and ready to do some scientific computing! Accesing Far Away Places via SSH Most of the time, scientists don’t run programs and store data on their own computers. Our personal computers simply are not powerful enough, do not have enough disk space, and do not have fast enough internet connections to act as a reasonable computing resource for us. Usually, we use our own command line and the command SSH to access the command line of a different computer.. In Bash Open your Bash shell using one of the methods described above. The syntax to use SSH is pretty simple: ssh &lt;your_user_name&gt;@&lt;domain_name&gt; To log into our computing resources, we will be using the following command: ssh -Y uvastudent@lwalab.phys.unm.edu This command says “Log me into the user uvastudent on the computer accessed by lwalab.phys.unm.edu (a computer at the University of New Mexico).” The -Y means “please forward me the graphics from that computer to mine”. If you have XQuartz (OSX) or XMing (Windows) open on your computer, then when you open a program with a graphical interface on the remote machine, the graphical interface will instead appear on your computer. When accessing the remote computer lwalab.phys.unm.edu for the first time, you will be prompted with a message something like The authenticity of host ... can&#39;t be established. Just type yes when you receive this message. You will also be asked for the password to the uvastudent account. Enter it when prompted. Don’t be worred when no text appears on the screen: it’s there, it’s just invisible. In PuTTY Open PuTTY, then type into the ‘Host Name (or IP address field)’, uvastudent@lwalab.phys.unm.edu. Then click the + next to SSH on the left menu. Then click X11 in the SSH submenu. Click the checkbox next to ‘Enable X11 fowarding’ and in the field ‘X display location’ type 0.0.0.0. This is equivalent to the -Y flag we passed to ssh before. Now click ‘Open’ at the bottom of the screen. Enter the password for our computing account and follow the instructions below. # Once logged into the lwalab.phy.unm.edu computer, run the following command: ssh -Y lwaucf1 You will have to enter the same password again. lwaucf1 can be replaced with lwaucf# (any number 1, 2, 3, 4, 5, or 6) to access any of the 6 LWA UCF computing nodes. Now we are saying, “Using my username (now uvastudent), log into the computer lwaucf#”. Now we are logged into the LWA computing cluster. This is where all of our data will be stored and we will run all of our commands to process the data. Using the Command Line Navigation Once logged in, you will be presented to a shell, similar to your own. We’re going to explore what’s on this computer by using textual commands. To execute a command, you type its name followed by the ‘Enter’ key to execute it. Type ls to list what is in the current directory. You should see two items: examples.desktop and uva_students. Type ls uva_students to list the contents of the uva_students folder. Type cd to change directory into uva_students, which moves you into the folder. Type ls again to list what’s in this directory. You should see another folder called sgs7cr. This is a folder I made for myself. Make a directory by typing mkdir &lt;your_id&gt;, where is replaced with your id. Type `ls` again to confirm your new folder was made. **Change directory** into the folder you just made by typing `cd `. Type `pwd` to **print** the **working directory**. It should output `/home/uvastudent/uva_students/sgs7cr`. Type `cd ~` to return to the home directory, which is where you started from. Type `pwd` again and notice that you are in the `/home/uvastudent` folder. The `~` is just a placeholder for the folder `/home/uvastudent`. These are the basic commands to move around and inspect the your computer’s files and folders: ls, cd. Copying Files The second important thing we do with our computers is move files around, delete them, and rename them. So how do we do that? We’re going to copy a file from my student directory to yours. Make sure you’re in the home directory (cd ~). Then use the command cp uva_students/sgs7cr/steven.txt uva_students/&lt;your_id&gt;/ to copy the file steven.txt to the directory called &lt;your_id&gt;. Notice that we can execute commands at any level of the file system. We can either cd to the folder sgs7cr then execute our cp command, or we can use cp from the home directory and simply specify the full path to the file we want to copy. All cp commands will come in the form cp &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt; Check out the other files that are in my directory using ls uva_students/sgs7cr/. How can we copy all of those files at once? You can do this by using the wildcard character *. * in bash stands for ‘anything’. For example, A* means ‘get me everything that starts with A’. *z means ‘get me everything that ends in z’. A*z means ‘get me everything that starts with A and ends with z’. Let’s copy everything from my directory to yours using the command cp uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ You should get a message cp: omitting directory ‘uva_students/sgs7cr/data’ cp: omitting directory ‘uva_students/sgs7cr/junk_folder’ cp: overwrite ‘uva_students/&lt;your_id&gt;/steven.txt’? . The first two messages mean that cp won’t work with directories. The third message means that the file steven.txt already exists in your directory and thus cp needs to confirm whether you want to keep or overwrite the old file. Simply type y or yes to confirm the request or n or no to deny it. Now, how do we resolve the fact that we can’t copy directories? All you need to do is use the command cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ The -r here simply means recursive and it just tells cp to copy everything from my folder, including all directories and everything inside those directories into the new folder. Before, cp didn’t know what to do when it reached a directory that isn’t empty. Type ls uva_students/&lt;your_id&gt;/ to confirm the contents of your directory. Finally, try running cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ again. You’ll notice that now you get a bunch of messages asking whether cp can overwrite your files. You could just hit y or n for every file that you’re copying. An alternative if you want to overwrite every file automatically is to use the command yes | cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ This command pipes the outpt of the command yes to the cp command. Try typing yes just for fun to see what it does. Type Ctrl+C to stop the infinite output of y. Moving and Renaming Files Similarly to cp, you can move files using the syntax mv &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt; To see this in action, let’s move steven.txt to a different location. Let’s go to your directory using cd uva_students/&lt;your_id&gt; and move the file steven.txt to &lt;your_name&gt;.txt using the command mv steven.txt &lt;your_name&gt;.txt Type ls to list what is in your directory now. Notice that steven.txt is gone and &lt;your_name&gt;.txt took it’s place. We can also use mv to rename files! Removing Files Now how do we delete files? Let’s go into the junk folder in your current directory: cd junk_folder. Type ls to check out what’s in your directory. Now let’s remove a file using rm junk_1.txt Check your directory again to make sure it’s gone. Notice that we also got a confirmation message here. If we don’t want to receive a confirmation message for rm, we can pass it the -f flag to force deletion. Try it: rm -f junk_2.txt Type ls to make sure it’s gone. Now what if we want to get rid of all of the files in this folder? If we remember our handy wildcard symbol * from before, then we could just use the command rm -f * to delete all of the files in the current directory. However, we’re just going to remove the entire junk_folder. Move up one directory using cd ... And now let’s try to remove the folder using rm junk_folder It should say rm: cannot remove ‘junk_folder/’: Is a directory. So how do we remove a directory if we can’t use rm? To make a directory, we used mkdir, so to remove a directory we would think to use rmdir. Try running it: rmdir junk_folder But this still will give an error: rmdir: failed to remove ‘junk_folder/’: Directory not empty. The best way to remove a directory is instead to use rm -r junk_folder Here, the -r means ‘recursive’, which just means when rm tries to remove junk_folder and junk_folder isn’t empty, it will first try to delete everything inside junk_folder by calling rm -r &lt;file&gt; on every file inside junk_folder. You will get a bunch of confirmation messages though asking if you want to enter into the directory and remove files. If we need to delete a lot of files, then this becomes a hassle. Instead, we can use rm -rf junk_folder and if we wanted to remove all files and folders in your current directory we would use rm -rf * !!!WARNING!!! I may have just taught you the most dangerous command you can run. rm -rf * will delete everything in the current directory without prompting you and with no way to recover any of it. Always be careful when removing files and folders using the command line. If you go to the home directory and call rm -rf * on then everyone’s files will be deleted with no way to recover them. Please heed these words of advice: Always be cautious with the commands you are running. It’s VERY likely that you will accidentally delete your own data, or the work of others. This has actually happened before! I’ve heard stories about students who have accidentally deleted the entirety of their research projects, or the entirety of the data they are basing their research on. Okay, now we know how to move about and explore the file system as well as move, copy, and delete files. The last few commands I will show you allow you to check up on the hardware of the computer you are working on. Type into the command line top Top is a simple command that lets you see a summary of the top processes (the ones using the most CPU resources) running on the computer right now. top gives you a lot of information to work with, but the most important things to look at are the columns labeled ‘PID’, ‘USER’, ‘%CPU’, and ‘COMMAND’. ‘COMMAND’ gives you the name of the proccess. For example, if you were running the web browser Firefox, then there would be a process called ‘firefox’ in the ‘COMMAND’ column. Next to ‘firefox’ in the ‘%CPU’ column you can see what percentage of the Central Processing Unit (CPU) Firefox is using. Under USER you can see who is running Firefox. Finally under PID you can see Firefox’s processor ID, which is just a unique numerical label assigned to Firefox. When you want to kill a process, you just type k while in top, then type in the PID of the process. Alternatively, if you know the PID after leaving top, you can return to the command line and type kill &lt;PID&gt; to kill the process. Next, we’ll look at the commands du and df. Go back to your own directory: cd ~/uva_students/&lt;your_id&gt;. Now type du -h du gives you the disk space usage of the current directory you are in. It spits back to you the sizes of all of the files and folders in your current directory. -h here means human readable, meaning it will give you sizes in terms of K, M, G, or T, which stand for kilobyte, megabyte, gigabyte, or terabyte respectively. We can also use the command df -h to show us the disk file system space usage. This means that it will show us how full all of the hard drives that are connected to our computing system are. Notice that a lot of the hard drives are pretty full! This means that we should be respectful of the other users on the system and quickly process, reduce, and delete the raw observational data that we obtain so that the file system doesn’t fill up. Vim - Making and Editting Files Previously, we’ve only moved around and deleted files that others have created? How do we make our own? When working over SSH, the most efficient way to create and edit files it use a slimmed down and efficient text editor, which you probably aren’t used to using. I’m going to be introducing you to one text editor called Vim. Vim Vim is a barebones, command line text editor which is popular among many scientists who have to use the command line a lot. Go to your directory cd ~/uva_students/&lt;your_id&gt;. Now type vim &lt;your_name&gt;.txt to open the text file &lt;your_name&gt;.txt. What you should see is a few lines of text followed by a bunch of tildes on the side and numbers and words on the bottom. Completely foreign and weird I know. Hit i on your keyboard to enter into Insert mode. You’ll notice at the bottom of the screen the words --INSERT--. This means that you can start adding and editing text to the file. Try it out. Use the arrow keys to move around (no way to click around in the command line). Hit Esc on your keyboard to escape to command mode. Now, if you start typing, you’ll notice that text doesn’t get added to the file, and some other weird stuff might happen. Don’t worry though. You only need to hit i to enter Insert mode to type stuff, or Esc to escape from Insert mode. Make sure you’re in the command mode. Now type :w. Notice that now the text shows up at the bottom. That’s because you’re entering a command. Hit Enter on your keyboard to execute :w which tells Vim to write the file. Now type :q to quit Vim. Now open up the text file again in Vim, as before. Enter into Insert mode using i and change the line my name is steven to my name is &lt;your_name&gt;. You can also write and quit at the same time using the command :wq. The way to search files in Vim is by using the command / while in command mode. Type /&lt;your_name&gt; to find your name in the text file. Type /i to find each occurance of the letter ‘i’ in the text file. Hit n on your keyboard to move forward to the next occurance of ‘i’ and type Shift+n to move to the previous occurance of ‘i’. Vim might seem a bit confusing and strange at first, but I promise you it is one of the fastest, most efficient, and most convienient ways to edit text files within the command line, so try to use it! If you hate Vim, there are other alternatives like Emacs and nano, which can be used the same way as Vim from the command line: emacs &lt;your_name&gt;.txt and nano &lt;your_name&gt;.txt But in my opinion, they are way harder to use without much benefit over good old Vim. Slightly More Advanced Stuff screen There’s a neat command called screen which lets you run multiple terminal “screens”. Try it out: screen This should open a new, fresh command line for you to use. Now type Ctrl+A then D to get out of the screen. Notice you get a message saying detached from .... That other bash session we opened is still alive! Type screen -ls To see a list of all of the current screens that are running. You may notice that the names of the screens are just numbers followed by characters. Those characters after the number are the session name, which we can and should specify. For our purposes, you should start new screens using the command screen -S &lt;your_id&gt; Let’s get back to the one you just created though. Type screen -ls to list the current screen and find the one you just opened. You can return to that screen using screen -x &lt;session_id&gt; You don’t have to type the entirety of the session ID, you just need to provide enough characters to differentiate it from all of the others. Since we will be using our user IDs to start new screens, use instead screen -x &lt;your_id&gt; PATH and Environment Variables You may have wondered what these strange commands we are running are. Well, they’re not actually inherent to Bash itself, they’re just programs that Bash knows how to execute. So where are these programs located and how does Bash know where to find them? The answer is the PATH. Type echo $PATH You should get as output /usr/local/sbin:/usr/local/bin:/usr/sbin:..., which is the names of a bunch of directires separated by colons. Each of these is the name is a folder that contains programs that you want Bash to be able to find. Notice that most of the folders have ‘bin’ in their name. This is a convention: On Linux systems, executable programs are usually installed to a folder called ‘bin’. Let’s try confusing Bash. Type export PATH=&quot;&quot; Now try using our old friend ls. It doesn’t work! You should get an error: -bash: ls: No such file or directory. Now type echo $PATH again. Nothing get’s printed out! That’s because in the previous export command we told Bash that the PATH is nothing (&quot;&quot;), therefore Bash has no idea where to look to find any of our programs (including ls). Let’s get things back to normal by typing export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/cuda/bin:/usr/local/tempo2/bin:/usr/local/presto/bin:/usr/local/casapy PATH is what is known in Bash as an ‘environment variable’. An environment variable is just a placeholder for a location (in the case of PATH) or some information that another program or Bash might use. You can set your own environment variables by using the command export &lt;var_name&gt;=&lt;var_defintion&gt; For example, let’s try export &lt;your_id&gt;=/home/uvastudent/uva_students/&lt;your_id&gt;/ Now try cd $&lt;your_id&gt; The $, which we saw before with echo just means replace the environment variable with what it contains. You should find that the previous command took you to your own folder, since $&lt;your_id&gt; was replaced with the path you specified before." />
<link rel="canonical" href="http://localhost:4000/tutorials/intro-command-line" />
<meta property="og:url" content="http://localhost:4000/tutorials/intro-command-line" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-07T00:00:00-04:00" />
<script type="application/ld+json">
{"description":"Accompanying lecture: Introduction to the Command Line Software to Install Make sure that you have each of the following software packages sucessfully installed before continuing. Mac (OS X) XQuartz Windows 10 The Windows 10 Linux Subsystem Xming WinSCP Windows (Not 10) PuTTY Xming WinSCP Bash and the Command Line You may have heard about using the command line before to interact with a computer. Most scientists are required to interact with computers without a Graphical User Interface (GUI) i.e. without a mouse or a screen. They need to run programs, create programs on remote computers, and move files around all without a mouse and a screen. The way they do this is by interacting with the computer via the command line, basically telling the computer through text what to do instead of through pointing and clicking, as most of us are used to. What is usually meant when people say “I use the command line” or “I use the terminal” is “I use Bash to work on my Unix machine”. Bash is what is known as a shell, which acts as a command interface between you and a computer which is running a Unix based operating system. It basically wraps the operating system with a human interface (hence the name shell). Unix is just a type of operating system, which many other operating systems are based on. Mac operating system OS X is actually based on Unix and there are also many flavors of Linux based on Unix as well (Red Hat, Ubuntu, CentOS, etc.). Windows is completely different, and a lot of the time that makes it unfit for scientific work if you need to use the command line a lot. Getting Set Up Mac (OS X) You already have a Bash command line on your computer! Simply open the application Terminal and you’re ready to go. This will open a Bash shell that lets you interact with your computer textually instead of visually. Windows Unfortunately, Windows is not based on the Unix operating system and thus it does not have a Bash shell. Instead it uses a different shell, which you can access all the same. Simply open the application Command Prompt. To find it, hit the Windows Key. If you are on Windows 10, just start typing “cmd” and it should pop up. On Windows 7, there should be a search function with the same capability, just type “cmd” into there to find the program. Since the shell provided by Windows is not Bash, it is largely irrelevant. If you don’t have Windows 10, this is the end of the road for you, and you’ll have to use PuTTY in order to access another machine which has a bash shell you can use, which we’ll talk about later. If you do have Windows 10, read on. Ubuntu on Windows If you use Windows 10, then you actually already have an Ubuntu installation on your computer. Follow this guide in order to get it set up on your computer. Once you have the Ubuntu subsystem set up, you can access a bash shell by opening the Command Prompt, as before, and simply typing bash to open the bash shell. Now, you’re set up and ready to do some scientific computing! Accesing Far Away Places via SSH Most of the time, scientists don’t run programs and store data on their own computers. Our personal computers simply are not powerful enough, do not have enough disk space, and do not have fast enough internet connections to act as a reasonable computing resource for us. Usually, we use our own command line and the command SSH to access the command line of a different computer.. In Bash Open your Bash shell using one of the methods described above. The syntax to use SSH is pretty simple: ssh &lt;your_user_name&gt;@&lt;domain_name&gt; To log into our computing resources, we will be using the following command: ssh -Y uvastudent@lwalab.phys.unm.edu This command says “Log me into the user uvastudent on the computer accessed by lwalab.phys.unm.edu (a computer at the University of New Mexico).” The -Y means “please forward me the graphics from that computer to mine”. If you have XQuartz (OSX) or XMing (Windows) open on your computer, then when you open a program with a graphical interface on the remote machine, the graphical interface will instead appear on your computer. When accessing the remote computer lwalab.phys.unm.edu for the first time, you will be prompted with a message something like The authenticity of host ... can&#39;t be established. Just type yes when you receive this message. You will also be asked for the password to the uvastudent account. Enter it when prompted. Don’t be worred when no text appears on the screen: it’s there, it’s just invisible. In PuTTY Open PuTTY, then type into the ‘Host Name (or IP address field)’, uvastudent@lwalab.phys.unm.edu. Then click the + next to SSH on the left menu. Then click X11 in the SSH submenu. Click the checkbox next to ‘Enable X11 fowarding’ and in the field ‘X display location’ type 0.0.0.0. This is equivalent to the -Y flag we passed to ssh before. Now click ‘Open’ at the bottom of the screen. Enter the password for our computing account and follow the instructions below. # Once logged into the lwalab.phy.unm.edu computer, run the following command: ssh -Y lwaucf1 You will have to enter the same password again. lwaucf1 can be replaced with lwaucf# (any number 1, 2, 3, 4, 5, or 6) to access any of the 6 LWA UCF computing nodes. Now we are saying, “Using my username (now uvastudent), log into the computer lwaucf#”. Now we are logged into the LWA computing cluster. This is where all of our data will be stored and we will run all of our commands to process the data. Using the Command Line Navigation Once logged in, you will be presented to a shell, similar to your own. We’re going to explore what’s on this computer by using textual commands. To execute a command, you type its name followed by the ‘Enter’ key to execute it. Type ls to list what is in the current directory. You should see two items: examples.desktop and uva_students. Type ls uva_students to list the contents of the uva_students folder. Type cd to change directory into uva_students, which moves you into the folder. Type ls again to list what’s in this directory. You should see another folder called sgs7cr. This is a folder I made for myself. Make a directory by typing mkdir &lt;your_id&gt;, where is replaced with your id. Type `ls` again to confirm your new folder was made. **Change directory** into the folder you just made by typing `cd `. Type `pwd` to **print** the **working directory**. It should output `/home/uvastudent/uva_students/sgs7cr`. Type `cd ~` to return to the home directory, which is where you started from. Type `pwd` again and notice that you are in the `/home/uvastudent` folder. The `~` is just a placeholder for the folder `/home/uvastudent`. These are the basic commands to move around and inspect the your computer’s files and folders: ls, cd. Copying Files The second important thing we do with our computers is move files around, delete them, and rename them. So how do we do that? We’re going to copy a file from my student directory to yours. Make sure you’re in the home directory (cd ~). Then use the command cp uva_students/sgs7cr/steven.txt uva_students/&lt;your_id&gt;/ to copy the file steven.txt to the directory called &lt;your_id&gt;. Notice that we can execute commands at any level of the file system. We can either cd to the folder sgs7cr then execute our cp command, or we can use cp from the home directory and simply specify the full path to the file we want to copy. All cp commands will come in the form cp &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt; Check out the other files that are in my directory using ls uva_students/sgs7cr/. How can we copy all of those files at once? You can do this by using the wildcard character *. * in bash stands for ‘anything’. For example, A* means ‘get me everything that starts with A’. *z means ‘get me everything that ends in z’. A*z means ‘get me everything that starts with A and ends with z’. Let’s copy everything from my directory to yours using the command cp uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ You should get a message cp: omitting directory ‘uva_students/sgs7cr/data’ cp: omitting directory ‘uva_students/sgs7cr/junk_folder’ cp: overwrite ‘uva_students/&lt;your_id&gt;/steven.txt’? . The first two messages mean that cp won’t work with directories. The third message means that the file steven.txt already exists in your directory and thus cp needs to confirm whether you want to keep or overwrite the old file. Simply type y or yes to confirm the request or n or no to deny it. Now, how do we resolve the fact that we can’t copy directories? All you need to do is use the command cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ The -r here simply means recursive and it just tells cp to copy everything from my folder, including all directories and everything inside those directories into the new folder. Before, cp didn’t know what to do when it reached a directory that isn’t empty. Type ls uva_students/&lt;your_id&gt;/ to confirm the contents of your directory. Finally, try running cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ again. You’ll notice that now you get a bunch of messages asking whether cp can overwrite your files. You could just hit y or n for every file that you’re copying. An alternative if you want to overwrite every file automatically is to use the command yes | cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/ This command pipes the outpt of the command yes to the cp command. Try typing yes just for fun to see what it does. Type Ctrl+C to stop the infinite output of y. Moving and Renaming Files Similarly to cp, you can move files using the syntax mv &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt; To see this in action, let’s move steven.txt to a different location. Let’s go to your directory using cd uva_students/&lt;your_id&gt; and move the file steven.txt to &lt;your_name&gt;.txt using the command mv steven.txt &lt;your_name&gt;.txt Type ls to list what is in your directory now. Notice that steven.txt is gone and &lt;your_name&gt;.txt took it’s place. We can also use mv to rename files! Removing Files Now how do we delete files? Let’s go into the junk folder in your current directory: cd junk_folder. Type ls to check out what’s in your directory. Now let’s remove a file using rm junk_1.txt Check your directory again to make sure it’s gone. Notice that we also got a confirmation message here. If we don’t want to receive a confirmation message for rm, we can pass it the -f flag to force deletion. Try it: rm -f junk_2.txt Type ls to make sure it’s gone. Now what if we want to get rid of all of the files in this folder? If we remember our handy wildcard symbol * from before, then we could just use the command rm -f * to delete all of the files in the current directory. However, we’re just going to remove the entire junk_folder. Move up one directory using cd ... And now let’s try to remove the folder using rm junk_folder It should say rm: cannot remove ‘junk_folder/’: Is a directory. So how do we remove a directory if we can’t use rm? To make a directory, we used mkdir, so to remove a directory we would think to use rmdir. Try running it: rmdir junk_folder But this still will give an error: rmdir: failed to remove ‘junk_folder/’: Directory not empty. The best way to remove a directory is instead to use rm -r junk_folder Here, the -r means ‘recursive’, which just means when rm tries to remove junk_folder and junk_folder isn’t empty, it will first try to delete everything inside junk_folder by calling rm -r &lt;file&gt; on every file inside junk_folder. You will get a bunch of confirmation messages though asking if you want to enter into the directory and remove files. If we need to delete a lot of files, then this becomes a hassle. Instead, we can use rm -rf junk_folder and if we wanted to remove all files and folders in your current directory we would use rm -rf * !!!WARNING!!! I may have just taught you the most dangerous command you can run. rm -rf * will delete everything in the current directory without prompting you and with no way to recover any of it. Always be careful when removing files and folders using the command line. If you go to the home directory and call rm -rf * on then everyone’s files will be deleted with no way to recover them. Please heed these words of advice: Always be cautious with the commands you are running. It’s VERY likely that you will accidentally delete your own data, or the work of others. This has actually happened before! I’ve heard stories about students who have accidentally deleted the entirety of their research projects, or the entirety of the data they are basing their research on. Okay, now we know how to move about and explore the file system as well as move, copy, and delete files. The last few commands I will show you allow you to check up on the hardware of the computer you are working on. Type into the command line top Top is a simple command that lets you see a summary of the top processes (the ones using the most CPU resources) running on the computer right now. top gives you a lot of information to work with, but the most important things to look at are the columns labeled ‘PID’, ‘USER’, ‘%CPU’, and ‘COMMAND’. ‘COMMAND’ gives you the name of the proccess. For example, if you were running the web browser Firefox, then there would be a process called ‘firefox’ in the ‘COMMAND’ column. Next to ‘firefox’ in the ‘%CPU’ column you can see what percentage of the Central Processing Unit (CPU) Firefox is using. Under USER you can see who is running Firefox. Finally under PID you can see Firefox’s processor ID, which is just a unique numerical label assigned to Firefox. When you want to kill a process, you just type k while in top, then type in the PID of the process. Alternatively, if you know the PID after leaving top, you can return to the command line and type kill &lt;PID&gt; to kill the process. Next, we’ll look at the commands du and df. Go back to your own directory: cd ~/uva_students/&lt;your_id&gt;. Now type du -h du gives you the disk space usage of the current directory you are in. It spits back to you the sizes of all of the files and folders in your current directory. -h here means human readable, meaning it will give you sizes in terms of K, M, G, or T, which stand for kilobyte, megabyte, gigabyte, or terabyte respectively. We can also use the command df -h to show us the disk file system space usage. This means that it will show us how full all of the hard drives that are connected to our computing system are. Notice that a lot of the hard drives are pretty full! This means that we should be respectful of the other users on the system and quickly process, reduce, and delete the raw observational data that we obtain so that the file system doesn’t fill up. Vim - Making and Editting Files Previously, we’ve only moved around and deleted files that others have created? How do we make our own? When working over SSH, the most efficient way to create and edit files it use a slimmed down and efficient text editor, which you probably aren’t used to using. I’m going to be introducing you to one text editor called Vim. Vim Vim is a barebones, command line text editor which is popular among many scientists who have to use the command line a lot. Go to your directory cd ~/uva_students/&lt;your_id&gt;. Now type vim &lt;your_name&gt;.txt to open the text file &lt;your_name&gt;.txt. What you should see is a few lines of text followed by a bunch of tildes on the side and numbers and words on the bottom. Completely foreign and weird I know. Hit i on your keyboard to enter into Insert mode. You’ll notice at the bottom of the screen the words --INSERT--. This means that you can start adding and editing text to the file. Try it out. Use the arrow keys to move around (no way to click around in the command line). Hit Esc on your keyboard to escape to command mode. Now, if you start typing, you’ll notice that text doesn’t get added to the file, and some other weird stuff might happen. Don’t worry though. You only need to hit i to enter Insert mode to type stuff, or Esc to escape from Insert mode. Make sure you’re in the command mode. Now type :w. Notice that now the text shows up at the bottom. That’s because you’re entering a command. Hit Enter on your keyboard to execute :w which tells Vim to write the file. Now type :q to quit Vim. Now open up the text file again in Vim, as before. Enter into Insert mode using i and change the line my name is steven to my name is &lt;your_name&gt;. You can also write and quit at the same time using the command :wq. The way to search files in Vim is by using the command / while in command mode. Type /&lt;your_name&gt; to find your name in the text file. Type /i to find each occurance of the letter ‘i’ in the text file. Hit n on your keyboard to move forward to the next occurance of ‘i’ and type Shift+n to move to the previous occurance of ‘i’. Vim might seem a bit confusing and strange at first, but I promise you it is one of the fastest, most efficient, and most convienient ways to edit text files within the command line, so try to use it! If you hate Vim, there are other alternatives like Emacs and nano, which can be used the same way as Vim from the command line: emacs &lt;your_name&gt;.txt and nano &lt;your_name&gt;.txt But in my opinion, they are way harder to use without much benefit over good old Vim. Slightly More Advanced Stuff screen There’s a neat command called screen which lets you run multiple terminal “screens”. Try it out: screen This should open a new, fresh command line for you to use. Now type Ctrl+A then D to get out of the screen. Notice you get a message saying detached from .... That other bash session we opened is still alive! Type screen -ls To see a list of all of the current screens that are running. You may notice that the names of the screens are just numbers followed by characters. Those characters after the number are the session name, which we can and should specify. For our purposes, you should start new screens using the command screen -S &lt;your_id&gt; Let’s get back to the one you just created though. Type screen -ls to list the current screen and find the one you just opened. You can return to that screen using screen -x &lt;session_id&gt; You don’t have to type the entirety of the session ID, you just need to provide enough characters to differentiate it from all of the others. Since we will be using our user IDs to start new screens, use instead screen -x &lt;your_id&gt; PATH and Environment Variables You may have wondered what these strange commands we are running are. Well, they’re not actually inherent to Bash itself, they’re just programs that Bash knows how to execute. So where are these programs located and how does Bash know where to find them? The answer is the PATH. Type echo $PATH You should get as output /usr/local/sbin:/usr/local/bin:/usr/sbin:..., which is the names of a bunch of directires separated by colons. Each of these is the name is a folder that contains programs that you want Bash to be able to find. Notice that most of the folders have ‘bin’ in their name. This is a convention: On Linux systems, executable programs are usually installed to a folder called ‘bin’. Let’s try confusing Bash. Type export PATH=&quot;&quot; Now try using our old friend ls. It doesn’t work! You should get an error: -bash: ls: No such file or directory. Now type echo $PATH again. Nothing get’s printed out! That’s because in the previous export command we told Bash that the PATH is nothing (&quot;&quot;), therefore Bash has no idea where to look to find any of our programs (including ls). Let’s get things back to normal by typing export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/cuda/bin:/usr/local/tempo2/bin:/usr/local/presto/bin:/usr/local/casapy PATH is what is known in Bash as an ‘environment variable’. An environment variable is just a placeholder for a location (in the case of PATH) or some information that another program or Bash might use. You can set your own environment variables by using the command export &lt;var_name&gt;=&lt;var_defintion&gt; For example, let’s try export &lt;your_id&gt;=/home/uvastudent/uva_students/&lt;your_id&gt;/ Now try cd $&lt;your_id&gt; The $, which we saw before with echo just means replace the environment variable with what it contains. You should find that the previous command took you to your own folder, since $&lt;your_id&gt; was replaced with the path you specified before.","@type":"BlogPosting","url":"http://localhost:4000/tutorials/intro-command-line","headline":"Computing Guide","dateModified":"2017-10-07T00:00:00-04:00","datePublished":"2017-10-07T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/tutorials/intro-command-line"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- Manual seo tags -->
    <title>Computing Guide</title>
    <!--
    <title>Computing Guide | UVa Pulsar Observers</title>
    <meta name="description" content="Accompanying lecture: Introduction to the Command LineSoftware to InstallMake sure that you have each of the following software packages sucessfully installe...">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
    <div class="branding">
        <a href="/">
            <img class="avatar" src="/assets/img/logo.svg" alt=""/>
        </a>

        <h1 class="site-title">
            <a href="/">UVa Pulsar Observers</a>
        </h1>
    </div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <!-- Uses new method of specified ordering in _data/navigation.yml -->
        
        <ul>
        
                
                    <li>
                    <div class="dropdown">
                            

                            <a href="#"> UVa</a>
                                    <button class="dropbtn">
                                    </button>
                            </a>

                            

                            <div class="dropdown-content">
                            
                                    <a href="/timing">Timing Group</a>
                            
                                    <a href="/lectures">Lectures</a>
                            
                                    <a href="/tutorials">Tutorials</a>
                            
                            </div>
                    </div>
                    </li>
                
        
                
                        <li>
                                <a href="/pulsar">Pulsars</a>
                        </li>
                
        
                
                        <li>
                                <a href="/LWA">LWA</a>
                        </li>
                
        
                
                        <li>
                                <a href="/about">About</a>
                        </li>
                
        
        </ul>

    <!-- Old method using site's pages with specified ordering
    <ul>
    

        

        


        

        


        

        

    

    
        <li>
            <a class="clear" href="/">
                Welcome
            </a>
        </li>
    

    
        


        

        


        

        


        

        


        

        


        

        


        

        


        

        

    
        <li>
            <a class="clear" href="/timing.html">
                UVa Timing
            </a>
        </li>
    
        

    

    
        


        

        

    

    
        <li>
            <a class="clear" href="/pulsar">
                Pulsars
            </a>
        </li>
    

    
        


        

        

    

    
        <li>
            <a class="clear" href="/LWA">
                LWA
            </a>
        </li>
    

    
        


        

        

    

    
        <li>
            <a class="clear" href="/about">
                About
            </a>
        </li>
    

    
        


         
    <li>
      <div class="dropdown">
        <a href="timing.html">
        <button class="dropbtn">Dropdown 
        </button>
        </a>
        <div class="dropdown-content">
          <a href="#">Link 1</a>
          <a href="#">Link 2</a>
          <a href="#">Link 3</a>
        </div>
      </div> 
    </li>

        
        
        
        
    </ul>
        -->
    </nav>
</header>

    <div class="content">
      <article >
  <header id="main" style="background-image: url('/')">
    <h1 id="Computing+Guide" class="title">
        Computing Guide
    </h1>
    
    
      
  </header>
  <section class="post-content"><p>Accompanying lecture: <a href="/lectures/intro-command-line">Introduction to the Command Line</a></p>

<h1 id="software-to-install">Software to Install</h1>
<p>Make sure that you have each of the following software packages sucessfully installed before continuing.</p>

<p>Mac (OS X)</p>

<ul>
  <li><a href="https://www.xquartz.org/">XQuartz</a></li>
</ul>

<p>Windows 10</p>

<ul>
  <li><a href="https://msdn.microsoft.com/en-us/commandline/wsl/install_guide">The Windows 10 Linux Subsystem</a></li>
  <li><a href="https://sourceforge.net/projects/xming/">Xming</a></li>
  <li><a href="https://winscp.net/eng/download.php">WinSCP</a></li>
</ul>

<p>Windows (Not 10)</p>

<ul>
  <li><a href="http://www.putty.org/">PuTTY</a></li>
  <li><a href="https://sourceforge.net/projects/xming/">Xming</a></li>
  <li><a href="https://winscp.net/eng/download.php">WinSCP</a></li>
</ul>

<h1 id="bash-and-the-command-line">Bash and the Command Line</h1>

<p>You may have heard about using the <strong>command line</strong> before to interact with a computer. Most scientists are required to interact with computers without a Graphical User Interface (GUI) i.e. without a mouse or a screen. They need to run programs, create programs on remote computers, and move files around all without a mouse and a screen. The way they do this is by interacting with the computer via the <strong>command line</strong>, basically telling the computer through <em>text</em> what to do instead of through pointing and clicking, as most of us are used to.</p>

<p>What is usually meant when people say “I use the command line” or “I use the terminal” is “I use Bash to work on my Unix machine”. Bash is what is known as a <strong>shell</strong>, which acts as a command interface between you and a computer which is running a Unix based operating system. It basically wraps the operating system with a human interface (hence the name shell). Unix is just a type of operating system, which many other operating systems are based on. Mac operating system OS X is actually based on Unix and there are also many flavors of Linux based on Unix as well (Red Hat, Ubuntu, CentOS, etc.). Windows is completely different, and a lot of the time that makes it unfit for scientific work if you need to use the command line <em>a lot</em>.</p>

<h2 id="getting-set-up">Getting Set Up</h2>

<h5 id="mac-os-x">Mac (OS X)</h5>
<p>You already have a Bash command line on your computer! Simply open the application <strong>Terminal</strong> and you’re ready to go. This will open a <strong>Bash</strong> shell that lets you interact with your computer textually instead of visually.</p>

<h5 id="windows">Windows</h5>
<p>Unfortunately, Windows is not based on the Unix operating system and thus it does not have a Bash shell. Instead it uses a different shell, which you can access all the same. Simply open the application <strong>Command Prompt</strong>. To find it, hit the Windows Key. If you are on Windows 10, just start typing “cmd” and it should pop up. On Windows 7, there should be a search function with the same capability, just type “cmd” into there to find the program. Since the shell provided by Windows is not Bash, it is largely irrelevant. If you don’t have Windows 10, this is the end of the road for you, and you’ll have to use <strong>PuTTY</strong> in order to access another machine which has a bash shell you can use, which we’ll talk about later. If you do have Windows 10, read on.</p>

<h5 id="ubuntu-on-windows">Ubuntu on Windows</h5>
<p>If you use Windows 10, then you actually already have an Ubuntu installation on your computer. Follow <a href="https://msdn.microsoft.com/en-us/commandline/wsl/install_guide">this guide</a> in order to get it set up on your computer. Once you have the Ubuntu subsystem set up, you can access a bash shell by opening the <strong>Command Prompt</strong>, as before, and simply typing <code class="highlighter-rouge">bash</code> to open the bash shell.</p>

<p>Now, you’re set up and ready to do some scientific computing!</p>

<h2 id="accesing-far-away-places-via-ssh">Accesing Far Away Places via SSH</h2>
<p>Most of the time, scientists don’t run programs and store data on their own computers. Our personal computers simply are not powerful enough, do not have enough disk space, and do not have fast enough internet connections to act as a reasonable computing resource for us. Usually, we use our own command line and the command <strong>SSH</strong> to access the command line of a <em>different</em> computer..</p>

<h3 id="in-bash">In Bash</h3>

<p>Open your Bash shell using one of the methods described above.</p>

<p>The syntax to use SSH is pretty simple:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh &lt;your_user_name&gt;@&lt;domain_name&gt;
</code></pre></div></div>

<p>To log into our computing resources, we will be using the following command:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-Y</span> uvastudent@lwalab.phys.unm.edu
</code></pre></div></div>
<p>This command says “Log me into the user uvastudent on the computer accessed by lwalab.phys.unm.edu (a computer at the University of New Mexico).” The <code class="highlighter-rouge">-Y</code> means “please forward me the graphics from that computer to mine”. If you have XQuartz (OSX) or XMing (Windows) open on your computer, then when you open a program with a graphical interface on the remote machine, the graphical interface will instead appear on your computer. When accessing the remote computer <code class="highlighter-rouge">lwalab.phys.unm.edu</code> for the first time, you will be prompted with a message something like <code class="highlighter-rouge">The authenticity of host ... can't be established.</code> Just type <code class="highlighter-rouge">yes</code> when you receive this message. You will also be asked for the password to the uvastudent account. Enter it when prompted. Don’t be worred when no text appears on the screen: it’s there, it’s just invisible.</p>

<h3 id="in-putty">In PuTTY</h3>
<p>Open PuTTY, then type into the ‘Host Name (or IP address field)’, <code class="highlighter-rouge">uvastudent@lwalab.phys.unm.edu</code>. Then click the + next to SSH on the left menu. Then click X11 in the SSH submenu. Click the checkbox next to ‘Enable X11 fowarding’ and in the field ‘X display location’ type <code class="highlighter-rouge">0.0.0.0</code>. This is equivalent to the <code class="highlighter-rouge">-Y</code> flag we passed to <code class="highlighter-rouge">ssh</code> before. Now click ‘Open’ at the bottom of the screen. Enter the password for our computing account and follow the instructions below.</p>

<p>#</p>

<p>Once logged into the <code class="highlighter-rouge">lwalab.phy.unm.edu</code> computer, run the following command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-Y</span> lwaucf1
</code></pre></div></div>
<p>You will have to enter the same password again. <code class="highlighter-rouge">lwaucf1</code> can be replaced with <code class="highlighter-rouge">lwaucf#</code> (any number 1, 2, 3, 4, 5, or 6) to access any of the 6 LWA UCF computing nodes. Now we are saying, “Using my username (now uvastudent), log into the computer lwaucf#”. 
Now we are logged into the LWA computing cluster. This is where all of our data will be stored and we will run all of our commands to process the data.</p>

<h2 id="using-the-command-line">Using the Command Line</h2>

<h3 id="navigation">Navigation</h3>
<p>Once logged in, you will be presented to a shell, similar to your own. We’re going to explore what’s on this computer by using textual commands. To execute a command, you type its name followed by the ‘Enter’ key to execute it. Type <code class="highlighter-rouge">ls</code> to <strong>list</strong> what is in the current directory. You should see two items: <code class="highlighter-rouge">examples.desktop</code> and <code class="highlighter-rouge">uva_students</code>. Type <code class="highlighter-rouge">ls uva_students</code> to <strong>list</strong> the contents of the <code class="highlighter-rouge">uva_students</code> folder. Type <code class="highlighter-rouge">cd</code> to <strong>change directory</strong> into <code class="highlighter-rouge">uva_students</code>, which moves you into the folder. Type <code class="highlighter-rouge">ls</code> again to <strong>list</strong> what’s in this directory. You should see another folder called <code class="highlighter-rouge">sgs7cr</code>. This is a folder I made for myself.  <strong>Make</strong> a <strong>directory</strong> by typing <code class="highlighter-rouge">mkdir &lt;your_id&gt;</code>, where <your_id> is replaced with your id. Type `ls` again to confirm your new folder was made. **Change directory** into the folder you just made by typing `cd <your_id>`. Type `pwd` to **print** the **working directory**. It should output `/home/uvastudent/uva_students/sgs7cr`. Type `cd ~` to return to the home directory, which is where you started from. Type `pwd` again and notice that you are in the `/home/uvastudent` folder. The `~` is just a placeholder for the folder `/home/uvastudent`.</your_id></your_id></p>

<p>These are the basic commands to move around and inspect the your computer’s files and folders: <code class="highlighter-rouge">ls</code>, <code class="highlighter-rouge">cd</code>.</p>

<h3 id="copying-files">Copying Files</h3>
<p>The second important thing we do with our computers is move files around, delete them, and rename them. So how do we do that? We’re going to copy a file from my student directory to yours. Make sure you’re in the home directory (<code class="highlighter-rouge">cd ~</code>). Then use the command</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>uva_students/sgs7cr/steven.txt uva_students/&lt;your_id&gt;/
</code></pre></div></div>
<p>to <strong>copy</strong> the file <code class="highlighter-rouge">steven.txt</code> to the directory called <code class="highlighter-rouge">&lt;your_id&gt;.</code> Notice that we can execute commands at <em>any level</em> of the file system. We can either <code class="highlighter-rouge">cd</code> to the folder <code class="highlighter-rouge">sgs7cr</code> then execute our <code class="highlighter-rouge">cp</code> command, or we can use <code class="highlighter-rouge">cp</code> from the home directory and simply specify the full <strong>path</strong> to the file we want to copy. All <code class="highlighter-rouge">cp</code> commands will come in the form</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt;
</code></pre></div></div>
<p>Check out the other files that are in my directory using <code class="highlighter-rouge">ls uva_students/sgs7cr/</code>. How can we copy <em>all</em> of those files at once? You can do this by using the <em>wildcard</em> character <code class="highlighter-rouge">*</code>. <code class="highlighter-rouge">*</code> in bash stands for ‘anything’. For example, <code class="highlighter-rouge">A*</code> means ‘get me everything that starts with A’. <code class="highlighter-rouge">*z</code> means ‘get me everything that ends in z’. <code class="highlighter-rouge">A*z</code> means ‘get me everything that starts with A and ends with z’. Let’s copy everything from my directory to yours using the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/
</code></pre></div></div>
<p>You should get a message <code class="highlighter-rouge">cp: omitting directory ‘uva_students/sgs7cr/data’
cp: omitting directory ‘uva_students/sgs7cr/junk_folder’
cp: overwrite ‘uva_students/&lt;your_id&gt;/steven.txt’? </code>. The first two messages mean that <code class="highlighter-rouge">cp</code> won’t work with directories. The third message means that the file <code class="highlighter-rouge">steven.txt</code> already exists in your directory and thus <code class="highlighter-rouge">cp</code> needs to confirm whether you want to keep or overwrite the old file. Simply type <code class="highlighter-rouge">y</code> or <code class="highlighter-rouge">yes</code> to confirm the request or <code class="highlighter-rouge">n</code> or <code class="highlighter-rouge">no</code> to deny it. Now, how do we resolve the fact that we can’t copy directories? All you need to do is use the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/
</code></pre></div></div>
<p>The <code class="highlighter-rouge">-r</code> here simply means <strong>recursive</strong> and it just tells <code class="highlighter-rouge">cp</code> to <strong>copy</strong> everything from my folder, including all directories and <em>everything inside</em> those directories into the new folder. Before, <code class="highlighter-rouge">cp</code> didn’t know what to do when it reached a directory that isn’t empty. Type <code class="highlighter-rouge">ls uva_students/&lt;your_id&gt;/</code> to confirm the contents of your directory. Finally, try running</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/
</code></pre></div></div>
<p>again. You’ll notice that now you get a bunch of messages asking whether <code class="highlighter-rouge">cp</code> can overwrite your files. You could just hit <code class="highlighter-rouge">y</code> or <code class="highlighter-rouge">n</code> for every file that you’re copying. An alternative if you want to overwrite every file automatically is to use the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yes | cp -r uva_students/sgs7cr/* uva_students/&lt;your_id&gt;/
</code></pre></div></div>
<p>This command <em>pipes</em> the outpt of the command <code class="highlighter-rouge">yes</code> to the <code class="highlighter-rouge">cp</code> command. Try typing <code class="highlighter-rouge">yes</code> just for fun to see what it does. Type <code class="highlighter-rouge">Ctrl+C</code> to stop the infinite output of <code class="highlighter-rouge">y</code>.</p>

<h3 id="moving-and-renaming-files">Moving and Renaming Files</h3>
<p>Similarly to <code class="highlighter-rouge">cp</code>, you can <strong>move</strong> files using the syntax</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mv &lt;path/to/source/file&gt; &lt;path/to/destination/folder/&gt;
</code></pre></div></div>
<p>To see this in action, let’s move <code class="highlighter-rouge">steven.txt</code> to a different location. Let’s go to your directory using <code class="highlighter-rouge">cd uva_students/&lt;your_id&gt;</code> and <strong>move</strong> the file <code class="highlighter-rouge">steven.txt</code> to <code class="highlighter-rouge">&lt;your_name&gt;.txt</code> using the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mv steven.txt &lt;your_name&gt;.txt
</code></pre></div></div>
<p>Type <code class="highlighter-rouge">ls</code> to <strong>list</strong> what is in your directory now. Notice that <code class="highlighter-rouge">steven.txt</code> is gone and <code class="highlighter-rouge">&lt;your_name&gt;.txt</code> took it’s place. We can also use <code class="highlighter-rouge">mv</code> to <strong>rename</strong> files!</p>
<h3 id="removing-files">Removing Files</h3>
<p>Now how do we delete files? Let’s go into the junk folder in your current directory: <code class="highlighter-rouge">cd junk_folder</code>. Type <code class="highlighter-rouge">ls</code> to check out what’s in your directory. Now let’s <strong>remove</strong> a file using</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm junk_1.txt
</code></pre></div></div>
<p>Check your directory again to make sure it’s gone. Notice that we also got a confirmation message here. If we don’t want to receive a confirmation message for <code class="highlighter-rouge">rm</code>, we can pass it the <code class="highlighter-rouge">-f</code> flag to <strong>force</strong> deletion. Try it:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm -f junk_2.txt
</code></pre></div></div>
<p>Type <code class="highlighter-rouge">ls</code> to make sure it’s gone. Now what if we want to get rid of all of the files in this folder? If we remember our handy wildcard symbol <code class="highlighter-rouge">*</code> from before, then we could just use the command <code class="highlighter-rouge">rm -f *</code> to delete all of the files in the current directory. However, we’re just going to remove the entire <code class="highlighter-rouge">junk_folder</code>. Move up one directory using <code class="highlighter-rouge">cd ..</code>. And now let’s try to remove the folder using</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm junk_folder
</code></pre></div></div>
<p>It should say <code class="highlighter-rouge">rm: cannot remove ‘junk_folder/’: Is a directory</code>. So how do we remove a directory if we can’t use <code class="highlighter-rouge">rm</code>? To make a directory, we used <code class="highlighter-rouge">mkdir</code>, so to <strong>remove</strong> a <strong>directory</strong> we would think to use <code class="highlighter-rouge">rmdir</code>. Try running it:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rmdir junk_folder
</code></pre></div></div>
<p>But this still will give an error: <code class="highlighter-rouge">rmdir: failed to remove ‘junk_folder/’: Directory not empty</code>. The best way to <strong>remove</strong> a directory is instead to use</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm -r junk_folder
</code></pre></div></div>
<p>Here, the <code class="highlighter-rouge">-r</code> means ‘recursive’, which just means when <code class="highlighter-rouge">rm</code> tries to remove <code class="highlighter-rouge">junk_folder</code> and <code class="highlighter-rouge">junk_folder</code> isn’t empty, it will first try to delete <em>everything</em> inside <code class="highlighter-rouge">junk_folder</code> by calling <code class="highlighter-rouge">rm -r &lt;file&gt;</code> on every file inside junk_folder. You will get a bunch of confirmation messages though asking if you want to enter into the directory and remove files. If we need to delete a lot of files, then this becomes a hassle. Instead, we can use</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm -rf junk_folder
</code></pre></div></div>
<p>and if we wanted to remove all files and folders in your current directory we would use</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm -rf *
</code></pre></div></div>
<p><strong>!!!WARNING!!!</strong> I may have just taught you the most dangerous command you can run. <code class="highlighter-rouge">rm -rf *</code> will delete <strong>everything</strong> in the current directory without prompting you and with <strong>no way to recover any of it</strong>. <strong>Always</strong> be careful when removing files and folders using the command line. If you go to the home directory and call <code class="highlighter-rouge">rm -rf *</code> on then <strong>everyone’s</strong> files will be deleted with no way to recover them. Please heed these words of advice: <strong>Always be cautious with the commands you are running. It’s VERY likely that you will accidentally delete your own data, or the work of others.</strong> This has actually happened before! I’ve heard stories about students who have accidentally deleted the entirety of their research projects, or the entirety of the data they are basing their research on.</p>

<p>Okay, now we know how to move about and explore the file system as well as move, copy, and delete files. The last few commands I will show you allow you to check up on the hardware of the computer you are working on.</p>

<p>Type into the command line</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top
</code></pre></div></div>
<p>Top is a simple command that lets you see a summary of the <strong>top</strong> processes (the ones using the most CPU resources) running on the computer right now. <code class="highlighter-rouge">top</code> gives you a lot of information to work with, but the most important things to look at are the columns labeled ‘PID’, ‘USER’, ‘%CPU’, and ‘COMMAND’. ‘COMMAND’ gives you the name of the proccess. For example, if you were running the web browser Firefox, then there would be a process called ‘firefox’ in the ‘COMMAND’ column. Next to ‘firefox’ in the ‘%CPU’ column you can see what percentage of the Central Processing Unit (CPU) Firefox is using. Under <code class="highlighter-rouge">USER</code> you can see who is running Firefox. Finally under <code class="highlighter-rouge">PID</code> you can see Firefox’s <strong>processor ID</strong>, which is just a unique numerical label assigned to Firefox. When you want to <strong>kill</strong> a process, you just type <code class="highlighter-rouge">k</code> while in <code class="highlighter-rouge">top</code>, then type in the PID of the process. Alternatively, if you know the PID after leaving <code class="highlighter-rouge">top</code>, you can return to the command line and type</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kill &lt;PID&gt;
</code></pre></div></div>
<p>to kill the process.</p>

<p>Next, we’ll look at the commands <code class="highlighter-rouge">du</code> and <code class="highlighter-rouge">df</code>. Go back to your own directory: <code class="highlighter-rouge">cd ~/uva_students/&lt;your_id&gt;</code>. Now type</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>du -h
</code></pre></div></div>
<p><code class="highlighter-rouge">du</code> gives you the <strong>disk</strong> space <strong>usage</strong> of the current directory you are in. It spits back to you the sizes of all of the files and folders in your current directory. <code class="highlighter-rouge">-h</code> here means <strong>human</strong> readable, meaning it will give you sizes in terms of <strong>K</strong>, <strong>M</strong>, <strong>G</strong>, or <strong>T</strong>, which stand for <strong>kilobyte</strong>, <strong>megabyte</strong>, <strong>gigabyte</strong>, or <strong>terabyte</strong> respectively.</p>

<p>We can also use the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df -h
</code></pre></div></div>
<p>to show us the <strong>disk file</strong> system space usage. This means that it will show us how full all of the hard drives that are connected to our computing system are. Notice that a lot of the hard drives are pretty full! This means that we should be respectful of the other users on the system and quickly process, reduce, and delete the raw observational data that we obtain so that the file system doesn’t fill up.</p>

<h2 id="vim---making-and-editting-files">Vim - Making and Editting Files</h2>
<p>Previously, we’ve only moved around and deleted files that others have created? How do we make our own? When working over SSH, the most efficient way to create and edit files it use a slimmed down and efficient text editor, which you probably aren’t used to using. I’m going to be introducing you to one text editor called Vim.</p>
<h3 id="vim">Vim</h3>
<p>Vim is a barebones, command line text editor which is popular among many scientists who have to use the command line <em>a lot</em>. Go to your directory <code class="highlighter-rouge">cd ~/uva_students/&lt;your_id&gt;</code>. Now type</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim &lt;your_name&gt;.txt
</code></pre></div></div>
<p>to open the text file <code class="highlighter-rouge">&lt;your_name&gt;.txt</code>. What you should see is a few lines of text followed by a bunch of tildes on the side and numbers and words on the bottom. Completely foreign and weird I know. Hit <code class="highlighter-rouge">i</code> on your keyboard to enter into <strong>Insert</strong> mode. You’ll notice at the bottom of the screen the words <code class="highlighter-rouge">--INSERT--</code>. This means that you can start adding and editing text to the file. Try it out. Use the <strong>arrow keys</strong> to move around (no way to click around in the command line). Hit <code class="highlighter-rouge">Esc</code> on your keyboard to <strong>escape</strong> to command mode. Now, if you start typing, you’ll notice that text doesn’t get added to the file, and some other weird stuff might happen. Don’t worry though. You only need to hit <code class="highlighter-rouge">i</code> to enter <strong>Insert</strong> mode to type stuff, or <code class="highlighter-rouge">Esc</code> to <strong>escape</strong> from Insert mode.</p>

<p>Make sure you’re in the <strong>command mode</strong>. Now type <code class="highlighter-rouge">:w</code>. Notice that now the text shows up at the bottom. That’s because you’re entering a command. Hit <code class="highlighter-rouge">Enter</code> on your keyboard to execute <code class="highlighter-rouge">:w</code> which tells Vim to <strong>write</strong> the file. Now type <code class="highlighter-rouge">:q</code> to <strong>quit</strong> Vim. Now open up the text file again in Vim, as before. Enter into <strong>Insert</strong> mode using <code class="highlighter-rouge">i</code> and change the line <code class="highlighter-rouge">my name is steven</code> to <code class="highlighter-rouge">my name is &lt;your_name&gt;</code>. You can also <strong>write</strong> and <strong>quit</strong> at the same time using the command <code class="highlighter-rouge">:wq</code>.</p>

<p>The way to search files in Vim is by using the command <code class="highlighter-rouge">/</code> while in command mode. Type <code class="highlighter-rouge">/&lt;your_name&gt;</code> to find your name in the text file. Type <code class="highlighter-rouge">/i</code> to find each occurance of the letter ‘i’ in the text file. Hit <code class="highlighter-rouge">n</code> on your keyboard to move forward to the <strong>next</strong> occurance of ‘i’ and type <code class="highlighter-rouge">Shift+n</code> to move to the <strong>previous</strong> occurance of ‘i’.</p>

<p>Vim might seem a bit confusing and strange at first, but I promise you it is one of the fastest, most efficient, and most convienient ways to edit text files within the command line, so try to use it! If you hate Vim, there are other alternatives like Emacs and nano, which can be used the same way as Vim from the command line:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>emacs &lt;your_name&gt;.txt
</code></pre></div></div>
<p>and</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano &lt;your_name&gt;.txt
</code></pre></div></div>
<p>But in my opinion, they are way harder to use without much benefit over good old Vim.</p>

<h2 id="slightly-more-advanced-stuff">Slightly More Advanced Stuff</h2>
<h3 id="screen">screen</h3>
<p>There’s a neat command called <code class="highlighter-rouge">screen</code> which lets you run multiple terminal “screens”. Try it out:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>screen
</code></pre></div></div>
<p>This should open a new, fresh command line for you to use. Now type <code class="highlighter-rouge">Ctrl+A</code> then <code class="highlighter-rouge">D</code> to get out of the screen. Notice you get a message saying <code class="highlighter-rouge">detached from ...</code>. That other bash session we opened is still alive! Type</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>screen -ls
</code></pre></div></div>
<p>To see a <strong>list</strong> of all of the current screens that are running. You may notice that the names of the screens are just numbers followed by characters. Those characters after the number are the session name, which we can and should specify. For our purposes, you should start new screens using the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>screen -S &lt;your_id&gt;
</code></pre></div></div>
<p>Let’s get back to the one you just created though. Type <code class="highlighter-rouge">screen -ls</code> to <strong>list</strong> the current screen and find the one you just opened. You can return to that screen using</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>screen -x &lt;session_id&gt;
</code></pre></div></div>
<p>You don’t have to type the entirety of the session ID, you just need to provide enough characters to differentiate it from all of the others. Since we will be using our user IDs to start new screens, use instead</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>screen -x &lt;your_id&gt;
</code></pre></div></div>
<h3 id="path-and-environment-variables">PATH and Environment Variables</h3>
<p>You may have wondered what these strange commands we are running are. Well, they’re not actually inherent to Bash itself, they’re just programs that Bash knows how to execute. So where are these programs located and how does Bash know where to find them? The answer is the PATH. Type</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo $PATH
</code></pre></div></div>
<p>You should get as output <code class="highlighter-rouge">/usr/local/sbin:/usr/local/bin:/usr/sbin:...</code>, which is the names of a bunch of directires separated by colons. Each of these is the name is a folder that contains programs that you want Bash to be able to find. Notice that most of the folders have ‘bin’ in their name. This is a convention: On Linux systems, <em>executable</em> programs are usually installed to a folder called ‘bin’. Let’s try confusing Bash. Type</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=""
</code></pre></div></div>
<p>Now try using our old friend <code class="highlighter-rouge">ls</code>. It doesn’t work! You should get an error: <code class="highlighter-rouge">-bash: ls: No such file or directory</code>. Now type <code class="highlighter-rouge">echo $PATH</code> again. Nothing get’s printed out! That’s because in the previous <code class="highlighter-rouge">export</code> command we told Bash that the PATH is nothing (<code class="highlighter-rouge">""</code>), therefore Bash has no idea where to look to find any of our programs (including <code class="highlighter-rouge">ls</code>). Let’s get things back to normal by typing</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/cuda/bin:/usr/local/tempo2/bin:/usr/local/presto/bin:/usr/local/casapy
</code></pre></div></div>
<p>PATH is what is known in Bash as an ‘environment variable’. An environment variable is just a placeholder for a location (in the case of PATH) or some information that another program or Bash might use. You can set your own environment variables by using the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export &lt;var_name&gt;=&lt;var_defintion&gt;
</code></pre></div></div>
<p>For example, let’s try</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export &lt;your_id&gt;=/home/uvastudent/uva_students/&lt;your_id&gt;/
</code></pre></div></div>
<p>Now try</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd $&lt;your_id&gt;
</code></pre></div></div>
<p>The <code class="highlighter-rouge">$</code>, which we saw before with <code class="highlighter-rouge">echo</code> just means replace the environment variable with what it contains. You should find that the previous command took you to your own folder, since <code class="highlighter-rouge">$&lt;your_id&gt;</code> was replaced with the path you specified before.</p>
</section>
    
    
  <!-- Tag list for portfolio -->
  
  



    
</article>

    </div>
    
<footer class="site-footer">
    <p class="text">&copy; Steven Stetzler
 | <a href="/credits">Credits</a></p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                


<li>
<a href="mailto:pulsarobservers@gmail.com" title="Email">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>













<li>
	<a href="https://github.com/pulsar-observers" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>
































                </ul>
            </div>
</footer>




  </body>
</html>
